plugins{
    id "java"
}

group = "powergridminimap"
version = "1.14.0"

java{
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

def mindustryVersion = (findProperty("mindustryVersion") ?: "v154.3").toString()
def arcVersion = (findProperty("arcVersion") ?: mindustryVersion).toString()

repositories{
    mavenCentral()
    maven{ url "https://jitpack.io" }
}

configurations.configureEach{
    resolutionStrategy.eachDependency{ details ->
        // Mindustry v154.3 can request Arc modules by commit hash, but JitPack hosts tag versions.
        if(details.requested.group == "com.github.Anuken.Arc" && details.requested.version == "ec5df18e54"){
            details.useVersion(arcVersion)
            details.because("Use JitPack Arc tag artifacts to avoid unavailable commit coordinates")
        }
    }
}

dependencies{
    // Prefer building against a local Mindustry source checkout (as an included subproject).
    if(rootProject.findProject(":core") != null){
        compileOnly project(":core")
    }else{
        // Standalone build: fetch Mindustry core from JitPack.
        compileOnly "com.github.Anuken.MindustryJitpack:core:$mindustryVersion"
    }
}

tasks.withType(JavaCompile).configureEach{
    options.encoding = "UTF-8"
    if(JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_1_9)){
        options.release.set(8)
    }
}

tasks.register("zipMod", Zip){
    group = "build"
    description = "Packages the mod as a .zip for Mindustry."
    dependsOn classes
    archiveFileName = "${project.name}.zip"
    destinationDirectory = layout.buildDirectory.dir("libs")
    from(sourceSets.main.output)
    from("README.md")
}

tasks.register("jarMod", Jar){
    group = "build"
    description = "Packages the mod as a .jar for Mindustry (Android-friendly)."
    dependsOn classes
    archiveFileName = "${project.name}.jar"
    destinationDirectory = layout.buildDirectory.dir("libs")
    from(sourceSets.main.output)
    from("README.md")
}

tasks.register("copyZipToDist", Copy){
    dependsOn(tasks.named("zipMod"))
    from(tasks.named("zipMod").flatMap{ it.archiveFile })
    into(new File(project.projectDir, "dist"))
    rename{ _ -> "${project.name}.zip" }
    doNotTrackState("Copying into dist is a convenience step; state tracking is unnecessary here.")
}

tasks.register("copyJarToDist", Copy){
    dependsOn(tasks.named("jarMod"))
    from(tasks.named("jarMod").flatMap{ it.archiveFile })
    into(new File(project.projectDir, "dist"))
    rename{ _ -> "${project.name}.jar" }
    doNotTrackState("Copying into dist is a convenience step; state tracking is unnecessary here.")
}

// Keep a copy in workspace root "构建/<mod-name>/" (mod name + version).
def buildCopyDir = new File(rootDir.parentFile, "构建/${project.name}")

tasks.register("copyZipToBuildFolder", Copy){
    dependsOn(tasks.named("zipMod"))
    from(tasks.named("zipMod").flatMap{ it.archiveFile })
    into(buildCopyDir)
    rename{ _ -> "${project.name}-${project.version}.zip" }
    doFirst{
        buildCopyDir.mkdirs()
    }
    doNotTrackState("Copying into workspace 构建 is a convenience step; state tracking is unnecessary here.")
}

tasks.register("copyJarToBuildFolder", Copy){
    dependsOn(tasks.named("jarMod"))
    from(tasks.named("jarMod").flatMap{ it.archiveFile })
    into(buildCopyDir)
    rename{ _ -> "${project.name}-${project.version}.jar" }
    doFirst{
        buildCopyDir.mkdirs()
    }
    doNotTrackState("Copying into workspace 构建 is a convenience step; state tracking is unnecessary here.")
}

tasks.named("zipMod").configure{
    finalizedBy tasks.named("copyZipToDist")
    finalizedBy tasks.named("copyZipToBuildFolder")
}

tasks.named("jarMod").configure{
    finalizedBy tasks.named("copyJarToDist")
    finalizedBy tasks.named("copyJarToBuildFolder")
}

def isWindows = System.getProperty("os.name").toLowerCase(Locale.ROOT).contains("windows")

def findD8 = {
    def explicit = System.getenv("D8_PATH")
    if(explicit){
        def f = new File(explicit)
        if(f.exists()) return f
    }

    def sdkRoot = System.getenv("ANDROID_SDK_ROOT") ?: System.getenv("ANDROID_HOME")
    if(sdkRoot){
        def buildToolsDir = new File(sdkRoot, "build-tools")
        if(buildToolsDir.isDirectory()){
            def toolName = isWindows ? "d8.bat" : "d8"
            def candidates = (buildToolsDir.listFiles() ?: [])
                .findAll{ it.isDirectory() }
                .sort{ a, b -> b.name <=> a.name }

            for(def dir : candidates){
                def exe = new File(dir, toolName)
                if(exe.exists()) return exe
            }
        }
    }

    // Local convenience: use the checked-in Android command line tools in workspace root, if present.
    if(isWindows){
        def workspaceRoot = rootDir.parentFile
        def matches = (workspaceRoot.listFiles() ?: [])
            .findAll{ it.isDirectory() && it.name.startsWith("commandlinetools-win-") }
            .sort{ a, b -> b.name <=> a.name }

        for(def dir : matches){
            def exe = new File(dir, "cmdline-tools/bin/d8.bat")
            if(exe.exists()) return exe
        }
    }

    return null
}

def androidDexOutDir = layout.buildDirectory.dir("d8").get().asFile

tasks.register("d8InputJar", Jar){
    group = "build"
    description = "Builds a jar used only as input for D8 (no dist side effects)."
    dependsOn tasks.named("classes")
    archiveFileName = "${project.name}-d8-input.jar"
    destinationDirectory = layout.buildDirectory.dir("d8-input")
    from(sourceSets.main.output)
}

tasks.register("dexAndroid", Exec){
    group = "build"
    description = "Compiles Java bytecode into classes.dex for Mindustry Android mod loading."
    dependsOn tasks.named("d8InputJar")

    doFirst{
        def d8 = findD8()
        if(d8 == null){
            throw new GradleException("D8 not found. Set ANDROID_SDK_ROOT/ANDROID_HOME or D8_PATH (or keep commandlinetools-win-* in workspace root on Windows).")
        }
        delete(androidDexOutDir)
        androidDexOutDir.mkdirs()

        def programJar = tasks.named("d8InputJar").get().archiveFile.get().asFile

        commandLine d8.absolutePath
        args "--min-api", "14", "--release", "--output", androidDexOutDir.absolutePath
        args programJar.absolutePath
    }
}

tasks.register("jarAndroid", Jar){
    group = "build"
    description = "Packages an Android-compatible mod JAR containing classes.dex."
    dependsOn tasks.named("dexAndroid")

    archiveFileName = "${project.name}-android.jar"
    destinationDirectory = layout.buildDirectory.dir("libs")

    from(androidDexOutDir){
        include "classes.dex"
    }
    from(sourceSets.main.output.resourcesDir)
    from("README.md")
}

tasks.register("copyAndroidJarToDist", Copy){
    dependsOn(tasks.named("jarAndroid"))
    from(tasks.named("jarAndroid").flatMap{ it.archiveFile })
    into(new File(project.projectDir, "dist"))
    rename{ _ -> "${project.name}-android.jar" }
    doNotTrackState("Copying into dist is a convenience step; state tracking is unnecessary here.")
}

tasks.register("copyAndroidJarToBuildFolder", Copy){
    dependsOn(tasks.named("jarAndroid"))
    from(tasks.named("jarAndroid").flatMap{ it.archiveFile })
    into(buildCopyDir)
    rename{ _ -> "${project.name}-${project.version}-android.jar" }
    doFirst{
        buildCopyDir.mkdirs()
    }
    doNotTrackState("Copying into workspace 构建 is a convenience step; state tracking is unnecessary here.")
}

tasks.named("jarAndroid").configure{
    finalizedBy tasks.named("copyAndroidJarToDist")
    finalizedBy tasks.named("copyAndroidJarToBuildFolder")
}
